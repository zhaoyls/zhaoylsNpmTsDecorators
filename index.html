<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>仅用于测试代码这里...</title>
</head>

<body>
    <script>
        const arr = [
            { id: 1, name: "总经办", parentId: 0 },
            { id: 2, name: "研发部", parentId: 1 },
            { id: 4, name: "行政人事部1", parentId: 1 },
            { id: 6, name: "行政人事部下4", parentId: 4 },
            { id: 7, name: "行政人事部4", parentId: 4 },
            { id: 20, name: "研发下2", parentId: 2 },
            { id: 21, name: "研发下2", parentId: 2 },
            { id: 22, name: "研发下2", parentId: 2 },
        ];


        function withIdToTree(arr, pid, pidName = 'parentId') {
            return arr
                .filter((item) => item[pidName] === pid)
                .map((item) => {
                    item.children = withIdToTree(arr, item.id);
                    return item;
                });
        }

        console.log('%c [ withIdToTree ]-35', 'font-size:13px; background:#94bfc1; color:#d8ffff;', withIdToTree(arr, 1))


        function listToTree(list, parentId = null) {
            const tree = [];
            // for (let i = 0; i < list.length; i++) {
            //     if (list[i].parentId === parentId) {
            //         const node = {
            //             parentId: parentId,
            //             id: list[i].id,
            //             name: list[i].name,
            //             children: listToTree(list, list[i].id)
            //         };
            //         tree.push(node);
            //     } else {
            //         tree.push(list[i]);
            //     }
            // }

            const map = {}
            for (let i = 0; i < list.length; i++) {
                const item = list[i];
                map[item.id] = { ...item, children: [] };
            }

            for (let i = 0; i < list.length; i++) {
                const item = map[list[i].id];
                if (item.parentId !== 0 && map[item.parentId]) {
                    map[item.parentId].children.push(item);
                } else {
                    tree.push(item);
                }
            }
            return tree;
        }

        console.log('%c [ listToTree ]-71', 'font-size:13px; background:#94bfc1; color:#d8ffff;', listToTree(arr, 1))
        //  数组扁平化
        function flatten(arr, depth = Infinity) {
            if (depth === 0) {
                return arr;
            }

            return arr.reduce((result, item) => {
                if (Array.isArray(item)) {
                    result.push(...flatten(item, depth - 1));
                } else {
                    result.push(item);
                }
                return result;
            }, []);
        }

        const array = [[0, 1], [2, [3, 4]], [5, 6]];
        const result = flatten(array);


        console.log('%c [flatten 数组扁平化结果  ]-89', 'font-size:13px; background:#45d773; color:#89ffb7;', result)

    </script>

    <!-- <script type="module" src="/tsup.config.ts">
    </script> -->

    <script>
        /**
         * this 问题。
         * */
        let a = 0; // 不是var 所以没有全局作用域，如果var 那么第一个fun()输出是 0
        const obj = {
            a: 1,
            b: function () {
                console.log(this.a);
            }
        }

        const obj1 = {
            a: 2
        }


        const fun = obj.b;
        fun() // undefined
        fun.apply(obj) // 1 (obj.fun...)

        fun.bind(obj1).apply(obj)//2

        const fun1 = fun.bind(obj1);

        new fun() // undefined


        // promiseAll
        function promiseAll(promises) {
            if (!Array.isArray(promises)) {
                throw new Error('参数必须是数组');
            }
            if (promises.length === 0) {
                return Promise.resolve([]);
            }
            return new Promise((resolve, reject) => {
                let results = [];
                let completedPromises = 0;

                promises.forEach((promise, index) => {
                    promise.then((result) => {
                        results[index] = result; // 顺序完成存储。
                        completedPromises++;

                        if (completedPromises === promises.length) {
                            resolve(results); // 所有完成
                        }
                    }).catch((error) => {
                        reject(error); // 失败直接拦截
                    });
                });
            });
        }
        // const p = promiseAll([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]).then((res) => {
        //     console.log(res);
        // }).catch((err) => {
        //     console.log(err);
        // })

        promiseAll([]).then((res) => {
            console.log(res);
        })
        Promise.all([]).then((res) => {
            console.log(res);
        })

        function PromiseLike(promise) {
            return !!promise && (typeof promise === 'object' || typeof promise === 'function') && typeof promise.then === 'function';
        }
        console.log(PromiseLike(Promise.resolve()))

        promiseRace([Promise.resolve(1)]).then((res) => {
            console.log(res);
        })

        function promiseRace(promise = []) {
            if (!Array.isArray(promise)) return Promise.reject(new Error('参数必须是数组'));
            return new Promise((resolve, reject) => {
                promise.forEach((item, index) => {
                  item.then((res) => {
                    resolve(res)
                  }).catch((err) => {
                        reject(err)
                    })
                })
            })
            // return new Promise((resolve, reject) => {
            //     promise.reduce(function (acc, item) {
            //         return acc.then(function () {
            //             return item;
            //         }).catch(function (err) {
            //             return Promise.reject(err);
            //         });
            //     }, Promise.resolve()).then(function (res) {
            //         return resolve(res);
            //     }, function (err) {
            //         return reject(err);
            //     });
            // });
        }

        // 快速排序
        // 思路：选择一个基准值，比基准值小的值都放在左边，比基准值大的值都放在右边
        // 递归地对左右两部分进行排序，最终合并成一个有序数组
        function quickSort(arr) {
            if (arr.length <= 1) return arr;
            let pivotIndex = Math.floor(arr.length / 2); // 选取基准值
            let pivot = arr.splice(pivotIndex, 1)[0]; // 把基准值从数组中取出 (删除的一项，返回的是数组)
            let left = []; // 存放比基准值小的值
            let right = []; // 存放比基准值大的值
            for (let i = 0; i < arr.length; i++) { // 分别把小于基准值和大于基准值的值放入两个数组中
                if (arr[i] < pivot) {
                    left.push(arr[i]);
                } else {
                    right.push(arr[i]);
                }
            }
            return quickSort(left).concat([pivot], quickSort(right)); // 递归地对左右两部分进行排序，最终合并成一个有序数组
        }
        
    </script>
</body>

</html>